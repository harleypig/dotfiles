#!/bin/bash

# Internal implementation notes for envsubstitute
#
# This script implements a custom envsubst-like utility with additional
# features:
#
# - Supports %WORD% format via SUBST_DELIM in addition to standard
#   $WORD/${WORD}
# - Uses alternation regex to handle both $WORD and ${WORD} formats separately
# - Implements NO_WARN mode that preserves unknown variables instead of
#   erroring
# - Uses --SKIP-- marker technique to prevent infinite loops when preserving
#   variables
#
# Key implementation details:
# - Regex: '\$\{([a-zA-Z_]+)\}|\$([a-zA-Z_]+)' for default mode
# - Regex: "${SUBST_DELIM}([^\\$SUBST_DELIM]*)$SUBST_DELIM" for SUBST_DELIM
#   mode
# - BASH_REMATCH[1] captures ${WORD} format, BASH_REMATCH[2] captures $WORD
#   format
# - When NO_WARN is set, unknown variables are temporarily replaced with
#   --SKIP-- markers to avoid regex re-matching, then restored after processing
# - Uses --SKIPSLASH-- markers to handle escaped variables (e.g., \$WORD)
#   which are temporarily replaced during processing and restored as literal
#   text with backslash prefix
# - Error messages convert $WORD to ${WORD} format for consistency

##############################################################################
#-----------------------------------------------------------------------------

# Determine whether we are being sourced or executed.
NOT_SOURCED=0
[[ ${BASH_SOURCE[0]} == "$0" ]] && NOT_SOURCED=1

declare selfname

# Set the appropriate return command.
if ((NOT_SOURCED)); then
  selfname="${0##*/}"
  RETURN='exit'
else
  selfname="envsubstitute"
  RETURN='return'
fi

#-----------------------------------------------------------------------------
warn() {
  [[ -n $NO_WARN ]] && return 0
  printf '%s\n' "$@" >&2
}

#-----------------------------------------------------------------------------
die() {
  (($#)) && warn "$@"
  exit 1
}

#-----------------------------------------------------------------------------
debug() { ((DEBUG)) && warn "$@"; }

#-----------------------------------------------------------------------------
usage() {
  warn "
Usage: $selfname 'input_string'
       echo 'input_string' | $selfname

A custom implementation of envsubst that replaces variable placeholders with
environment variable values. Unlike standard envsubst, this version supports
additional placeholder formats and provides better control over error
handling.

Supported formats:
  \$WORD or \${WORD}    (default, like envsubst)
  %WORD%              (when SUBST_DELIM=%)

Escaping:
  Use backslash to prevent substitution: \\\$WORD, \\\${WORD}, or \\%WORD%

Environment variables:
  SUBST_DELIM    Set delimiter character (e.g., '%' for %WORD% format)
  NO_WARN        If set, leave unknown variables unchanged instead of showing
                 errors. Without NO_WARN, unknown variables show error messages.

Examples:
  NAME=John $selfname 'Hello \$NAME'                    # Output: Hello John
  NAME=John $selfname 'Hello \${NAME}'                  # Output: Hello John
  SUBST_DELIM=% NAME=John $selfname 'Hello %NAME%'     # Output: Hello John
  $selfname 'Hello \\\$NAME'                             # Output: Hello \$NAME (escaped)
  NO_WARN=1 $selfname 'Hello \$UNKNOWN'                 # Output: Hello \$UNKNOWN (preserved)
  $selfname 'Hello \$UNKNOWN'                           # Shows error, outputs with error message

" "$@"
}

##############################################################################
#-----------------------------------------------------------------------------

# Check for help flags first, before processing input
for arg in "$@"; do
  case "$arg" in
    -h|--help)
      usage
      $RETURN 0
      ;;
  esac
done

_envsubst() {
  local s match regex skipslash skiptext skipvar value varname words
  local -i loopcount rc

  skiptext='--SKIP--'
  skipslash='--SKIPSLASH--'
  loopcount=1000

  # Check for help in the function too, in case it's called directly
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    usage
    return 0
  fi

  if [[ -z $1 ]]; then
    # Read from STDIN.
    s=$(cat -)
  else
    s="$*"
  fi

  #---------------------------------------------------------------------------
  if [[ -n $SUBST_DELIM ]]; then
    regex="\\\\?$SUBST_DELIM([a-zA-Z_]+)$SUBST_DELIM"
    skipvar="$SUBST_DELIM"
    words="${SUBST_DELIM}WORD${SUBST_DELIM}s"

  else
    regex='\\?\$\{([a-zA-Z_]+)\}|\\?\$([a-zA-Z_]+)'
    skipvar='$'
    words="\$WORDs or \${WORD}s"
  fi

  debug "regex: $regex"
  debug "skipvar: $skipvar"

  #---------------------------------------------------------------------------
  [[ $s =~ $regex ]] || {
    rc=$?

    ((rc == 1)) && {
      warn "No $words found in string '%s'."
      printf '%s' "$s"
      return $rc
    }

    # Force warning on real problems.
    ((rc => 2)) && unset NO_WARN
    ((rc == 2)) && die "Syntax error in $selfname's regex."
    ((rc > 2)) && die "Unknown error from =~ in $selfname."
  }

  #---------------------------------------------------------------------------
  count=0
  while [[ $s =~ $regex ]]; do
    match="${BASH_REMATCH[0]}"

    if [[ -n ${BASH_REMATCH[1]} ]]; then
      # Match '${WORD}' or '%WORD%'
      varname="${BASH_REMATCH[1]}"
      value="$match"

    else
      # Match '$WORD'
      varname="${BASH_REMATCH[2]}"
      value="\${$varname}"
    fi

    debug "($LINENO) match:   $match"
    debug "($LINENO) varname: $varname"
    debug "($LINENO) value:   $value"

    if [[ $match == \\* ]]; then
      value="${skipslash}${match:2}"
      debug "($LINENO) value: $value"
      s=${s//\\$match/$value}

    else
      if [[ -v $varname ]]; then
        value="${!varname}"

      elif [[ -z $NO_WARN ]]; then
        warn "Variable '$varname' does not exist in the environment"
        value="${value%?}: NOT FOUND${value: -1}"

      else
        value="${skiptext}${match:1}"
      fi

      debug "($LINENO) value: $value"
      s=${s//$match/$value}
    fi

    debug "($LINENO) s: $s"

    ((count++))
    ((count>loopcount)) && die "Too many substitutions - possible infinite loop"
  done

  s="${s//$skiptext/$skipvar}"
  s="${s//$skipslash/\\$skipvar}"
  printf '%s' "$s"
}

((NOT_SOURCED)) \
  && _envsubst "$@" \
  && $RETURN $?
