#!/bin/bash

##############################################################################
# Functions
#-----------------------------------------------------------------------------
warn() { printf '%s\n' "$@" >&2; }
die() { (($#)) && warn "$@"; exit 1; }

#-----------------------------------------------------------------------------
usage() {
  local usage_text
  usage_text=$(cat <<EOT
Usage: ${0##*/}
EOT
)

  # If message provided, append it to usage text
  (($#)) && usage_text+=$'\n\n'"$*"$'\n\n'

  die "$usage_text"
}

##############################################################################
# Setup and Sanity
#-----------------------------------------------------------------------------
[[ -n $VAULT_TOKEN ]] \
  || die "Vault token is not set. Set that by running the following command
and entering your LDAP password:

source set-vault-token"

#-----------------------------------------------------------------------------
# Parameter handling
declare vaultpaths="$XDG_CACHE_HOME/vault-paths"
declare credspath="${XDG_CACHE_HOME:-$HOME/.cache}/gcp-creds"
declare scname scpath credsfile
declare -a scnames

if [[ -n $1 ]]; then
  scname="$1"

else
  [[ -f azure-pipelines.yml ]] \
    || die "No parameter provided and no azure-pipelines.yml found in current directory"

  # Extract service connection names from azure-pipelines.yml
  readarray -t scnames < <(grep -i "tfServiceConnectionName:" azure-pipelines.yml |
                          sed -E '
                            s/^[^:]*://;                      # Get value after colon
                            s/#.*$//;                         # Remove comments
                            s/["'\'']//g;                     # Remove quotes
                            s/^[[:space:]]*|[[:space:]]*$//g; # Trim whitespace
                            s/^(sandbox|zions)-cloud-(dev|test)?-//; # Remove prefix
                            s/[-_]/[-_]/g;                    # Replace dashes/underscores with character class
                            /^$/d                             # Remove empty lines
                          ')

  if [[ ${#scnames[@]} -eq 0 ]]; then
    die "No service connection names found in azure-pipelines.yml"

  elif [[ ${#scnames[@]} -eq 1 ]]; then
    scname="${scnames[0]}"

  else
    echo "Multiple service connections found:"
    PS3="Select a service connection (0 to cancel): "

    select name in "${scnames[@]}" "Cancel"; do
      if [[ "$REPLY" == "0" || "$name" == "Cancel" ]]; then
        die "Operation cancelled by user"

      elif [[ -n "$name" ]]; then
        scname="$name"
        break
      fi
    done
  fi
fi

#-----------------------------------------------------------------------------
# get-vault-key returns a json format with 'creds.json' => value and 'path' =>
# the path to the key. The result of the following command, if not null, needs
# to be parsed out to credspath+="$path" and
# credsfile="$credspath/creds.json", AI!
scpath="$(get-vault-key get "$scname" "creds.json" 2> /dev/null)"

[[ -n $scpath ]] || die "Could not find credentials for '$scname'"

# Create credentials directory if it doesn't exist
mkdir -p "$credspath"

credsfile="$credspath/${1//\//-}.json"

#-----------------------------------------------------------------------------
# Get credentials and save to file
if [[ -z $scpath ]]; then
  # If we have a service connection name but no path yet, find it
  scpath=$(get-vault-key get "dai/gcp/$scname" "creds.json" 2>/dev/null)
  [[ -n $scpath ]] || die "Could not find credentials for service connection '$scname'"
fi

# Save credentials to file
echo "$scpath" | base64 -d | jq -S '.' > "$credsfile"

# Set environment variable
export GOOGLE_APPLICATION_CREDENTIALS="$credsfile"
echo "GCP credentials set to: $credsfile"
echo "GOOGLE_APPLICATION_CREDENTIALS has been exported"
