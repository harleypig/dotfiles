#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long qw(:config bundling pass_through);

my @original_argv = @ARGV;
my %cli = (
    drop_defaults => 1,
    condense      => 1,
    quiet         => 0,
);

GetOptions(
    'rc=s'          => \$cli{rc},
    'no-rc'         => \$cli{no_rc},
    'keep-defaults' => sub { $cli{drop_defaults} = 0 },
    'condense!'     => \$cli{condense},
    'quiet|q'       => \$cli{quiet},
    'help|h'        => sub { usage(0) },
) or usage(1);

my @perltidy_args = @ARGV;    # pass-through arguments for perltidy

if ( $cli{rc} && $cli{no_rc} ) {
    die "--rc and --no-rc are mutually exclusive\n";
}

my ( $rc_source, $rc_origin );
if ( $cli{no_rc} ) {
    my $empty = "";
    $rc_source = \$empty;
    $rc_origin = 'none (empty profile)';
}
elsif ( $cli{rc} ) {
    $rc_source = $cli{rc};
    $rc_origin = $cli{rc};
}
else {
    $rc_source = undef;
    $rc_origin = 'perltidy search path';
}

my (
    $error_message,         $rOpts,               $rGetopt_flags,
    $rsections,             $rabbreviations,      $rOpts_default,
    $rabbreviations_default
) = read_perltidyrc( $rc_source, \@perltidy_args );

die $error_message if $error_message;

my %equals_default = build_equals_default( $rOpts, $rOpts_default );
my %section_notes;

my %clean_opts;
if ( $cli{no_rc} ) {
    # Start from defaults and overlay any explicit options passed through.
    %clean_opts = ( %{$rOpts_default}, %{$rOpts} );
    %equals_default =
      build_equals_default( \%clean_opts, $rOpts_default );
}
else {
    %clean_opts = %{$rOpts};
    if ( $cli{drop_defaults} ) {
        foreach my $long_name ( keys %clean_opts ) {
            delete $clean_opts{$long_name} if $equals_default{$long_name};
        }
    }
}

condense_options( \%clean_opts, $rsections, \%section_notes ) if $cli{condense};

detect_conflicts( \%clean_opts, $rsections, \%section_notes );

my %abbreviations_user =
  user_defined_abbreviations( $rabbreviations, $rabbreviations_default );

if ( %clean_opts || %abbreviations_user ) {
    dump_options(
        quiet              => $cli{quiet},
        cmdline            => join( ' ', $0, @original_argv ),
        rc_origin          => $rc_origin,
        opts               => \%clean_opts,
        getopt_flags       => $rGetopt_flags,
        sections           => $rsections,
        abbreviations      => $rabbreviations,
        equals_default     => \%equals_default,
        abbreviations_user => \%abbreviations_user,
        section_notes      => \%section_notes,
    );
}
else {
    print STDERR "No configuration parameters remain after filtering.\n";
}

exit 0;

sub usage {
    my ($exit_code) = @_;
    $exit_code = 0 unless defined $exit_code;
    print <<'USAGE';
perltidyrc-clean [--rc FILE | --no-rc] [--keep-defaults] [--[no-]condense]
                 [--quiet] [--help]

  --rc FILE         Load the specified perltidyrc instead of searching.
  --no-rc           Do not load any perltidyrc (process from empty state).
  --keep-defaults   Keep options which match perltidy defaults (normally
                    removed).
  --[no-]condense   Drop fine-grained options that duplicate broader settings
                    (on by default).
  --quiet, -q       Omit header comments in the output.
  --help, -h        Show this message.

Any additional arguments are passed directly to perltidy; perltidy will report
an error if it does not recognize them.

The output is a cleaned perltidyrc grouped by the Formatting Options sections
from the perltidy manual.
USAGE
    exit $exit_code;
}

sub build_equals_default {
    my ( $opts, $defaults ) = @_;
    my %equals_default;
    foreach my $long_name ( keys %{$opts} ) {
        my $val = $opts->{$long_name};
        next unless defined $defaults->{$long_name};
        my $default_val = $defaults->{$long_name};
        $equals_default{$long_name} = defined($val)
          && defined($default_val)
          && $default_val eq $val;
    }
    return %equals_default;
}

sub condense_options {
    my ( $opts, $sections, $section_notes ) = @_;

    if ( exists $opts->{'brace-tightness'} ) {
        my $general = $opts->{'brace-tightness'};
        my @brace_specific = qw(
          block-brace-tightness
          brace-vertical-tightness
          brace-vertical-tightness-closing
          brace-follower-vertical-tightness
          block-brace-vertical-tightness
        );
        foreach my $key (@brace_specific) {
            if ( exists $opts->{$key} && defined $opts->{$key}
                && $opts->{$key} eq $general )
            {
                add_section_note( $sections, $section_notes, $key,
                    "$key removed; equals brace-tightness" );
                delete $opts->{$key};
            }
        }
    }

    if ( exists $opts->{'indent-columns'}
        && exists $opts->{'continuation-indentation'} )
    {
        if ( $opts->{'continuation-indentation'} eq $opts->{'indent-columns'} )
        {
            add_section_note(
                $sections, $section_notes, 'continuation-indentation',
                "continuation-indentation removed; equals indent-columns"
            );
            delete $opts->{'continuation-indentation'};
        }
    }
}

sub detect_conflicts {
    my ( $opts, $sections, $section_notes ) = @_;
    $section_notes ||= {};

    if ( is_true( $opts->{'brace-left-and-indent'} )
        && is_true( $opts->{'non-indenting-braces'} ) )
    {
        add_section_note(
            $sections, $section_notes, 'brace-left-and-indent',
            "brace-left-and-indent conflicts with non-indenting-braces"
        );
    }

    if ( is_true( $opts->{tabs} )
        && is_true( $opts->{'entab-leading-whitespace'} ) )
    {
        add_section_note(
            $sections, $section_notes, 'tabs',
            "tabs together with entab-leading-whitespace may conflict"
        );
    }

    if ( defined $opts->{'brace-tightness'} ) {
        my $general = $opts->{'brace-tightness'};
        foreach my $specific (
            qw(block-brace-tightness brace-vertical-tightness
            brace-vertical-tightness-closing brace-follower-vertical-tightness
            block-brace-vertical-tightness)
          )
        {
            next unless defined $opts->{$specific};
            if ( $opts->{$specific} ne $general ) {
                add_section_note(
                    $sections, $section_notes, $specific,
                    "$specific differs from brace-tightness; specific wins"
                );
            }
        }
    }

    if ( defined $opts->{'maximum-line-length'}
        && defined $opts->{'fuzzy-line-length'} )
    {
        my $max   = $opts->{'maximum-line-length'};
        my $fuzzy = $opts->{'fuzzy-line-length'};
        if ( looks_like_number($max)
            && looks_like_number($fuzzy)
            && $fuzzy > $max )
        {
            add_section_note(
                $sections, $section_notes, 'fuzzy-line-length',
                "fuzzy-line-length ($fuzzy) exceeds maximum-line-length ($max)"
            );
        }
    }

    if ( exists $opts->{format}
        && !is_true( $opts->{format} )
        && ( is_true( $opts->{'format-skipping'} )
        || is_true( $opts->{'detect-format-skipping-from-start'} ) ) )
    {
        add_section_note(
            $sections, $section_notes, 'format',
            "format is disabled but format-skipping detection is enabled"
        );
    }
}

sub is_true {
    my ($value) = @_;
    return 0 unless defined $value;
    return $value =~ /^[1-9]\d*$/ ? 1 : $value ? 1 : 0;
}

sub looks_like_number {
    my ($value) = @_;
    return defined($value) && $value =~ /^-?\d+(?:\.\d+)?$/;
}

sub add_section_note {
    my ( $sections, $section_notes, $opt, $text ) = @_;
    my $section = $sections->{$opt} // 'UNKNOWN';
    push @{ $section_notes->{$section} }, $text;
}

sub user_defined_abbreviations {
    my ( $abbrev, $abbrev_default ) = @_;
    my %abbrev_user;
    foreach my $key ( keys %{$abbrev} ) {
        next if $abbrev_default->{$key};
        $abbrev_user{$key} = $abbrev->{$key};
    }
    return %abbrev_user;
}

sub dump_options {
    my (%args) = @_;
    my $cmdline            = $args{cmdline};
    my $rc_origin          = $args{rc_origin};
    my $quiet              = $args{quiet};
    my $rOpts              = $args{opts};
    my $rGetopt_flags      = $args{getopt_flags};
    my $rsections          = $args{sections};
    my $rabbreviations     = $args{abbreviations};
    my $requals_default    = $args{equals_default};
    my $rabbreviations_user = $args{abbreviations_user};
    my $section_notes      = $args{section_notes} // {};

    my %section_and_name;
    my %saw_section;
    foreach my $long_name ( keys %{$rOpts} ) {
        my $section = $rsections->{$long_name} // 'UNKNOWN';
        $section_and_name{$section}{$long_name} = $rOpts->{$long_name};
        $saw_section{$section}++;
    }

    unless ($quiet) {
        my $date = localtime();
        print "# perltidy configuration file created $date\n";
        print "# using: $cmdline\n";
        print "# source: $rc_origin\n";
    }

    foreach my $section (
        sort {
            section_order($a) <=> section_order($b) || $a cmp $b
        } keys %saw_section
      )
    {
        unless ($quiet) {
            print "\n";
            my $trimmed = $section;
            $trimmed =~ s/^\d+\. //;
            print "# $trimmed\n";
            if ( my $notes = $section_notes->{$section} ) {
                foreach my $note (@{$notes}) {
                    print "# NOTE: $note\n";
                }
            }
        }

        my $rname_value = $section_and_name{$section};
        foreach my $long_name ( sort keys %{$rname_value} ) {
            my $flag  = $rGetopt_flags->{$long_name};
            my $value = $rname_value->{$long_name};
            my ( $prefix, $suffix ) = ( '--', '' );
            if ($flag) {
                if ( $flag =~ /^=/ || $flag =~ /^:/ ) {
                    if ( $value !~ /^\d+$/ ) {
                        $value = '"' . $value . '"';
                    }
                    $suffix = '=' . $value;
                }
                elsif ( $flag =~ /^!/ ) {
                    $prefix       .= 'no' unless $value;
                }
                else {
                    print
"# ERROR in dump_options: unrecognized flag $flag for $long_name\n";
                }
            }

            my $long_option = $prefix . $long_name . $suffix;

            if ($quiet) {
                print $long_option . "\n";
            }
            else {
                print $long_option . "\n";
            }
        }
    }

    if ( %{$rabbreviations_user} ) {
        unless ($quiet) {
            print "\n";
            print "# Abbreviations\n";
        }
        foreach my $key ( sort keys %{$rabbreviations_user} ) {
            my @vals = @{ $rabbreviations_user->{$key} };
            print $key . ' {' . join( ' ', @vals ) . '}' . "\n";
        }
    }
}

sub section_order {
    my ($section) = @_;
    return $1 if $section =~ /^(\d+(?:\.\d+)?)/;
    return 999;
}

sub read_perltidyrc {
    my ( $config_file, $perltidy_args ) = @_;
    $perltidy_args ||= [];
    my $error_message = "";
    my %Opts;

    eval "use Perl::Tidy";
    if ($@) {
        $error_message = "Perl::Tidy not installed\n";
        return ( $error_message, \%Opts );
    }

    my $version = $Perl::Tidy::VERSION;
    if ( $version < 20060528 ) {
        $error_message = "perltidy version $version cannot read options\n";
        return ( $error_message, \%Opts );
    }

    my $stderr = "";
    my @argv_empty;

    my %Opts_default;
    my %abbreviations_default;
    my $empty_rc = "";
    my $err = Perl::Tidy::perltidy(
        perltidyrc         => \$empty_rc,
        dump_options       => \%Opts_default,
        dump_options_type  => 'full',
        dump_abbreviations => \%abbreviations_default,
        stderr             => \$stderr,
        argv               => \@argv_empty,
    );
    if ($err) {
        die "Error calling perltidy for defaults\n";
    }

    my %Getopt_flags;
    my %sections;
    my %abbreviations;
    $stderr = "";
    my $err2 = Perl::Tidy::perltidy(
        perltidyrc            => $config_file,
        dump_options          => \%Opts,
        dump_options_type     => 'perltidyrc',
        dump_getopt_flags     => \%Getopt_flags,
        dump_options_category => \%sections,
        dump_abbreviations    => \%abbreviations,
        stderr                => \$stderr,
        argv                  => $perltidy_args,
    );

    $error_message .= $stderr;
    if ($err2) {
        $error_message ||= "";
        $error_message .= "perltidy reported an error while parsing options\n";
    }

    return ( $error_message, \%Opts, \%Getopt_flags, \%sections,
        \%abbreviations, \%Opts_default, \%abbreviations_default );
}

