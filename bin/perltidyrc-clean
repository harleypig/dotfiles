#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long qw(:config bundling pass_through);

# ------------------------------------------------------------------------------

# Check for Perl::Tidy dependency early
eval "use Perl::Tidy";
if ($@) {
    die "Perl::Tidy not installed\n";
}

my $version = $Perl::Tidy::VERSION;
if ( $version < 20060528 ) {
    die "perltidy version $version cannot read options\n";
}

# ------------------------------------------------------------------------------

my @original_argv = @ARGV;
my %cli = (
    drop_defaults         => 1,
    condense              => 1,
    quiet                 => 0,
    keep_defaults         => 0,
    add_missing_defaults  => 0,
    expand_options        => 1,
    outfile               => undef,
);

my $empty = "";    # Declared here to remain valid for reference

# ------------------------------------------------------------------------------

sub usage {
    my ($exit_code) = @_;
    $exit_code = 0 unless defined $exit_code;
    print <<'USAGE';
perltidyrc-clean [--rc FILE | --no-rc] [--keep-defaults] [--[no-]condense]
                 [--quiet] [--help]

  --rc FILE         Load the specified perltidyrc instead of searching.
  --no-rc           Do not load any perltidyrc (process from empty state).
  --keep-defaults   Keep options which match perltidy defaults (normally
                    removed). Does NOT add missing defaults; use
                    --add-missing-defaults for that.
  --add-missing-defaults
                    Add any missing default options (implies --keep-defaults
                    and --no-condense).
  --[no-]condense   Drop fine-grained options that duplicate broader settings
                    (on by default).
  --[no-]expand-options
                    Expand short options to their long names (default on).
  --outfile FILE, -o FILE
                    Write output to FILE instead of stdout. Recognized even
                    though not used when parsing options.
  --quiet, -q       Omit header comments in the output.
  --help, -h        Show this message.

Any additional arguments are passed directly to perltidy; perltidy will report
an error if it does not recognize them.

The output is a cleaned perltidyrc grouped by the Formatting Options sections
from the perltidy manual.
USAGE
    exit $exit_code;
}

sub is_true {
    my ($value) = @_;
    return 0 unless defined $value;
    return $value =~ /^[1-9]\d*$/ ? 1 : $value ? 1 : 0;
}

sub looks_like_number {
    my ($value) = @_;
    return defined($value) && $value =~ /^-?\d+(?:\.\d+)?$/;
}

sub add_section_note {
    my ( $sections, $section_notes, $opt, $text ) = @_;
    my $section = $sections->{$opt} // 'UNKNOWN';
    push @{ $section_notes->{$section} }, $text;
}

sub section_order {
    my ($section) = @_;
    return $1 if $section =~ /^(\d+(?:\.\d+)?)/;
    return 999;
}

sub expand_abbrev {
    my ( $arg, $abbr ) = @_;
    return $arg unless $arg =~ /^-{1,2}(no)?([A-Za-z0-9_-]+)(=.*)?$/;
    my ( $no, $name, $suffix ) = ( $1 // '', $2, $3 // '' );
    my $long = $abbr->{$name};
    return $arg unless $long;
    my $prefix = '--';
    my $neg    = $no ? 'no' : '';
    return $prefix . $neg . $long . ($suffix // '');
}

# Compare options against defaults and return a hash indicating which options
# equal their default values. Used to identify options that can be removed
# when --drop-defaults is enabled.
sub build_equals_default {
    my ( $opts, $defaults ) = @_;
    my %equals_default;
    foreach my $long_name ( keys %{$opts} ) {
        my $val = $opts->{$long_name};
        next unless defined $defaults->{$long_name};
        my $default_val = $defaults->{$long_name};
        $equals_default{$long_name} = defined($val)
          && defined($default_val)
          && $default_val eq $val;
    }
    return %equals_default;
}

sub extract_outfile {
    my ($args) = @_;
    my $outfile;
    my @filtered;
    while (@$args) {
        my $arg = shift @$args;
        # Combined regex: matches -o, --outfile, -ofilename,
        # --outfile=filename, or --outfilefilename (but we're not going to
        #document that last one)
        if ( $arg =~ /^(?:-o|--outfile=?)(\S*)$/ ) {
            $outfile = $1;
            # If no filename attached, check next arg (if it's not an option)
            if ( !$outfile && @$args && $args->[0] !~ /^-/ ) {
                $outfile = shift @$args;
            }
            elsif ( !$outfile ) {
                die "Error: --outfile or -o requires a filename\n";
            }
            next;
        }
        push @filtered, $arg;
    }
    @$args = @filtered;
    return $outfile;
}

# Short options in users rc file
sub user_defined_abbreviations {
    my ( $abbrev, $abbrev_default ) = @_;
    my %abbrev_user;
    foreach my $key ( keys %{$abbrev} ) {
        next if $abbrev_default->{$key};
        $abbrev_user{$key} = $abbrev->{$key};
    }
    return %abbrev_user;
}

sub condense_options {
    my ( $opts, $sections, $section_notes ) = @_;

    if ( exists $opts->{'brace-tightness'} ) {
        my $general = $opts->{'brace-tightness'};
        my @brace_specific = qw(
          block-brace-tightness
          brace-vertical-tightness
          brace-vertical-tightness-closing
          brace-follower-vertical-tightness
          block-brace-vertical-tightness
        );
        foreach my $key (@brace_specific) {
            if ( exists $opts->{$key} && defined $opts->{$key}
                && $opts->{$key} eq $general )
            {
                add_section_note( $sections, $section_notes, $key,
                    "$key removed; equals brace-tightness" );
                delete $opts->{$key};
            }
        }
    }

    if ( exists $opts->{'indent-columns'}
        && exists $opts->{'continuation-indentation'} )
    {
        if ( $opts->{'continuation-indentation'} eq $opts->{'indent-columns'} )
        {
            add_section_note(
                $sections, $section_notes, 'continuation-indentation',
                "continuation-indentation removed; equals indent-columns"
            );
            delete $opts->{'continuation-indentation'};
        }
    }
}

sub detect_conflicts {
    my ( $opts, $sections, $section_notes ) = @_;
    $section_notes ||= {};

    if ( is_true( $opts->{'brace-left-and-indent'} )
        && is_true( $opts->{'non-indenting-braces'} ) )
    {
        add_section_note(
            $sections, $section_notes, 'brace-left-and-indent',
            "brace-left-and-indent conflicts with non-indenting-braces"
        );
    }

    if ( is_true( $opts->{tabs} )
        && is_true( $opts->{'entab-leading-whitespace'} ) )
    {
        add_section_note(
            $sections, $section_notes, 'tabs',
            "tabs together with entab-leading-whitespace may conflict"
        );
    }

    if ( defined $opts->{'brace-tightness'} ) {
        my $general = $opts->{'brace-tightness'};
        foreach my $specific (
            qw(block-brace-tightness brace-vertical-tightness
            brace-vertical-tightness-closing brace-follower-vertical-tightness
            block-brace-vertical-tightness)
          )
        {
            next unless defined $opts->{$specific};
            if ( $opts->{$specific} ne $general ) {
                add_section_note(
                    $sections, $section_notes, $specific,
                    "$specific differs from brace-tightness; specific wins"
                );
            }
        }
    }

    if ( defined $opts->{'maximum-line-length'}
        && defined $opts->{'fuzzy-line-length'} )
    {
        my $max   = $opts->{'maximum-line-length'};
        my $fuzzy = $opts->{'fuzzy-line-length'};
        if ( looks_like_number($max)
            && looks_like_number($fuzzy)
            && $fuzzy > $max )
        {
            add_section_note(
                $sections, $section_notes, 'fuzzy-line-length',
                "fuzzy-line-length ($fuzzy) exceeds maximum-line-length ($max)"
            );
        }
    }

    if ( exists $opts->{format}
        && !is_true( $opts->{format} )
        && ( is_true( $opts->{'format-skipping'} )
        || is_true( $opts->{'detect-format-skipping-from-start'} ) ) )
    {
        add_section_note(
            $sections, $section_notes, 'format',
            "format is disabled but format-skipping detection is enabled"
        );
    }
}

sub dump_options {
    my (%args) = @_;
    my $cmdline            = $args{cmdline};
    my $rc_origin          = $args{rc_origin};
    my $quiet              = $args{quiet};
    my $rOpts              = $args{opts};
    my $rGetopt_flags      = $args{getopt_flags};
    my $rsections          = $args{sections};
    my $rabbreviations     = $args{abbreviations};
    my $requals_default    = $args{equals_default};
    my $rabbreviations_user = $args{abbreviations_user};
    my $section_notes      = $args{section_notes} // {};
    my $keep_defaults      = $args{keep_defaults} // 0;
    my $destination        = $args{destination};    # scalar ref or undef

    my %section_and_name;
    my %saw_section;
    foreach my $long_name ( keys %{$rOpts} ) {
        my $section = $rsections->{$long_name} // 'UNKNOWN';
        $section_and_name{$section}{$long_name} = $rOpts->{$long_name};
        $saw_section{$section}++;
    }

    my $append = sub {
        my ($text) = @_;
        if ($destination) {
            $$destination .= $text;
        }
        else {
            print $text;
        }
    };

    unless ($quiet) {
        my $date = localtime();
        $append->("# perltidy configuration file created $date\n");
        $append->("# using: $cmdline\n");
        $append->("# source: $rc_origin\n");
    }

    foreach my $section (
        sort {
            section_order($a) <=> section_order($b) || $a cmp $b
        } keys %saw_section
      )
    {
        unless ($quiet) {
            $append->("\n");
            my $trimmed = $section;
            $trimmed =~ s/^\d+\. //;
            $append->("# $trimmed\n");
            if ( my $notes = $section_notes->{$section} ) {
                foreach my $note (@{$notes}) {
                    $append->("# NOTE: $note\n");
                }
            }
        }

        my $rname_value = $section_and_name{$section};
        foreach my $long_name ( sort keys %{$rname_value} ) {
            my $flag  = $rGetopt_flags->{$long_name};
            my $value = $rname_value->{$long_name};
            my ( $prefix, $suffix ) = ( '--', '' );
            if ($flag) {
                if ( $flag =~ /^=/ || $flag =~ /^:/ ) {
                    if ( $value !~ /^\d+$/ ) {
                        $value = '"' . $value . '"';
                    }
                    $suffix = '=' . $value;
                }
                elsif ( $flag =~ /^!/ ) {
                    $prefix       .= 'no' unless $value;
                }
                else {
                    $append->(
"# ERROR in dump_options: unrecognized flag $flag for $long_name\n");
                }
            }

            my $long_option = $prefix . $long_name . $suffix;

            if ( $keep_defaults && $requals_default->{$long_name} ) {
                $long_option .= " #  default";
            }
            $append->($long_option . "\n");
        }
    }

    if ( %{$rabbreviations_user} ) {
        unless ($quiet) {
            $append->("\n");
            $append->("# Abbreviations\n");
        }
        foreach my $key ( sort keys %{$rabbreviations_user} ) {
            my @vals = @{ $rabbreviations_user->{$key} };
            $append->($key . ' {' . join( ' ', @vals ) . '}' . "\n");
        }
    }
}

sub read_perltidyrc {
    my ( $config_file, $perltidy_args, $expand_options ) = @_;
    $perltidy_args ||= [];
    my $error_message = "";
    my %Opts;

    my $stderr = "";
    my @argv_empty = ();

    # Declare hashes before building parameter hash
    my %Opts_default;
    my %abbreviations_default;

    # Build parameter hash explicitly for defaults dump
    my %params_default = (
        perltidyrc         => \"",    # empty scalar ref for empty config
        dump_options       => \%Opts_default,
        dump_options_type  => 'full',
        dump_abbreviations => \%abbreviations_default,
        stderr             => \$stderr,
        argv               => \@argv_empty,
    );

    # Validate parameter hash (hashes always have even number of elements)
    die "Internal error: invalid parameter hash for defaults dump"
      unless keys(%params_default) > 0;
    my $err = Perl::Tidy::perltidy(%params_default);
    if ($err == 1) {
        die "Error calling perltidy for defaults: $stderr\n";
    }
    elsif ($err == 2) {
        warn "Warnings from perltidy defaults: $stderr\n";
    }

    my %Getopt_flags;
    my %sections;
    my %abbreviations;
    $stderr = "";
    
    # Expand short options if requested
    if ($expand_options) {
        my %abbr_single;
        foreach my $k ( keys %abbreviations_default ) {
            my @vals = @{ $abbreviations_default{$k} };
            next unless @vals == 1;
            $abbr_single{$k} = $vals[0];
        }
        @$perltidy_args =
          map { expand_abbrev( $_, \%abbr_single ) } @$perltidy_args;
    }

    # Build parameter hash explicitly for config dump
    # Only include perltidyrc if --rc or --no-rc was used (not undef)
    my %params_config = (
        dump_options          => \%Opts,
        dump_options_type     => 'perltidyrc',
        dump_getopt_flags     => \%Getopt_flags,
        dump_options_category => \%sections,
        dump_abbreviations    => \%abbreviations,
        stderr                => \$stderr,
        argv                  => $perltidy_args,    # array ref, even if empty
    );
    # Only add perltidyrc if explicitly specified (--rc or --no-rc)
    # If undef, Perl::Tidy will use its default search behavior
    if ( defined $config_file ) {
        $params_config{perltidyrc} = $config_file;    # filename string or scalar ref
    }

    # Validate parameter hash (hashes always have even number of elements)
    die "Internal error: invalid parameter hash for config dump"
      unless keys(%params_config) > 0;

    my $err2 = Perl::Tidy::perltidy(%params_config);

    $error_message .= $stderr;
    if ($err2 == 1) {
        $error_message ||= "";
        $error_message .= "perltidy reported an error while parsing options\n";
    }
    elsif ($err2 == 2) {
        # Warnings are already in $stderr, just note them
    }

    return ( $error_message, \%Opts, \%Getopt_flags, \%sections,
        \%abbreviations, \%Opts_default, \%abbreviations_default );
}

sub set_keep_defaults {
    $cli{drop_defaults} = 0;
    $cli{keep_defaults} = 1;
}

sub set_add_missing_defaults {
    $cli{add_missing_defaults} = 1;
    $cli{drop_defaults}        = 0;
    $cli{keep_defaults}        = 1;
    $cli{condense}             = 0;    # implies --no-condense
}

# ------------------------------------------------------------------------------

GetOptions(
    'rc=s'          => \$cli{rc},
    'no-rc'         => \$cli{no_rc},
    'keep-defaults' => \&set_keep_defaults,
    'add-missing-defaults' => \&set_add_missing_defaults,
    'expand-options!'  => \$cli{expand_options},
    'condense!'     => \$cli{condense},
    'quiet|q'       => \$cli{quiet},
    'help|h'        => sub { usage(0) },
) or usage(1);

# Fail fast on mutually exclusive flags.
if ( $cli{rc} && $cli{no_rc} ) {
    die "--rc and --no-rc are mutually exclusive\n";
}

# Extract outfile before any perltidy handling; remaining args pass through.
# Extract from @ARGV since we'll pass @ARGV to Perl::Tidy
$cli{outfile} = extract_outfile( \@ARGV );

# Clean @ARGV: filter out file arguments since we're only dumping options,
# not processing source files. Keep only option-like arguments for Perl::Tidy.
# GetOptions already removed our CLI options, so @ARGV contains pass-through args.
@ARGV = grep { /^-/ } @ARGV;    # Keep only option-like arguments

my ( $rc_source, $rc_origin ) = ( undef, 'perltidy search path' );
if ( $cli{no_rc} ) {
    $rc_source = \$empty;
    $rc_origin = 'none (empty profile)';
}
elsif ( $cli{rc} ) {
    $rc_source = $cli{rc};
    $rc_origin = $cli{rc};
}

my (
    $error_message,         $rOpts,               $rGetopt_flags,
    $rsections,             $rabbreviations,      $rOpts_default,
    $rabbreviations_default
) = read_perltidyrc( $rc_source, \@ARGV, $cli{expand_options} );

die $error_message if $error_message;

my %equals_default = build_equals_default( $rOpts, $rOpts_default );
my %section_notes;

my %clean_opts;
if ( $cli{no_rc} ) {
    # Start from defaults and overlay any explicit options passed through.
    %clean_opts = ( %{$rOpts_default}, %{$rOpts} );
}
else {
    if ( $cli{add_missing_defaults} ) {
        %clean_opts = ( %{$rOpts_default}, %{$rOpts} );
    }
    else {
        %clean_opts = %{$rOpts};
        if ( $cli{drop_defaults} ) {
            foreach my $long_name ( keys %clean_opts ) {
                delete $clean_opts{$long_name} if $equals_default{$long_name};
            }
        }
    }
}

%equals_default = build_equals_default( \%clean_opts, $rOpts_default );

condense_options( \%clean_opts, $rsections, \%section_notes )
  if $cli{condense};

detect_conflicts( \%clean_opts, $rsections, \%section_notes );

my %abbreviations_user =
  user_defined_abbreviations( $rabbreviations, $rabbreviations_default );

if ( %clean_opts || %abbreviations_user ) {
    my $output = "";
    dump_options(
        quiet              => $cli{quiet},
        cmdline            => join( ' ', $0, @original_argv ),
        rc_origin          => $rc_origin,
        opts               => \%clean_opts,
        getopt_flags       => $rGetopt_flags,
        sections           => $rsections,
        abbreviations      => $rabbreviations,
        equals_default     => \%equals_default,
        abbreviations_user => \%abbreviations_user,
        section_notes      => \%section_notes,
        keep_defaults      => $cli{keep_defaults},
        destination        => \$output,
    );
    
    if ( $cli{outfile} ) {
        open my $fh, '>', $cli{outfile}
          or die "Cannot open $cli{outfile} for writing: $!\n";
        print $fh $output;
        close $fh;
    }
    else {
        print $output;
    }
}
else {
    print STDERR "No configuration parameters remain after filtering.\n";
}

exit 0;
