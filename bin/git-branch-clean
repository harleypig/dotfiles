#!/bin/bash
#
# git-branch-clean - Delete local branches that no longer exist on remote
#
# Usage: git branch-clean [-n|-f] [-a] [-h]
#
# Options:
#   -n  Dry run - show what would be deleted
#   -f  Force delete branches (required for actual deletion)
#   -a  Include branches never pushed to remote
#   -h  Show this help message

##############################################################################
# Setup and Sanity
set -euo pipefail

# Process command line options
dry_run=0
force=0
all=0

##############################################################################
# Functions

#-----------------------------------------------------------------------------
# Rename process_branch to remove_branch, AI!
process_branch() {
  local branch="$1"
  local reason="$2"
  
  if [[ -n "$branch" ]]; then
    if ((dry_run)); then
      echo "Would delete branch: $branch ($reason)"
    elif ((force)); then
      echo "Deleting branch: $branch"
      git branch -D "$branch"
    fi
  fi
}

# Show help if no parameters
if [[ $# -eq 0 ]]; then
  sed -n '/^# Usage:/,/^$/ s/^# \?//p' "$0"
  exit 0
fi

while getopts "nfah" opt; do
  case $opt in
    n) dry_run=1 ;;
    f) force=1 ;;
    a) all=1 ;;
    h)
      sed -n '/^# Usage:/,/^$/ s/^# \?//p' "$0"
      exit 0
      ;;
    *) 
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
  esac
done

# Require -f for actual deletion
if [[ $force -eq 0 && $dry_run -eq 0 ]]; then
  echo "Error: -f required for branch deletion" >&2
  echo "Use -n for dry run or -h for help" >&2
  exit 1
fi

# Ensure we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
  echo "Error: not a git repository" >&2
  exit 1
fi

# Fetch and prune to ensure we have current remote information
git fetch --prune

# Find branches with gone upstreams
# Format: refs/heads/branch-name [gone]
readarray -t gone_branches < <(git for-each-ref --format '%(refname) %(upstream:track)' refs/heads |
                              awk '$2 == "[gone]" {sub("refs/heads/", "", $1); print $1}')

for branch in "${gone_branches[@]}"; do
  process_branch "$branch" "remote branch gone"
done

# If -a specified, find branches never pushed
if ((all)); then
  # Get branch listing with verbose info (-vv)
  # Find lines that:
  #   - Don't start with * (not current branch)
  #   - Don't have [...] (no upstream tracking)
  # Then extract and trim the branch name
  readarray -t unpushed_branches < <(git branch -vv |
                                    awk '/^[^*]/ && ! /\[.*\]/ {
                                      gsub(/^[[:space:]]+|[[:space:]]+$/, "", $1)
                                      print $1
                                    }')

  for branch in "${unpushed_branches[@]}"; do
    process_branch "$branch" "never pushed"
  done
fi
