# Peruse /usr/share/doc/xterm/*

# http://wiki.bash-hackers.org/scripting/terminalcodes

# Bash allows these prompt strings to be customized by inserting a
# number of backslash-escaped special characters that are
# decoded as follows:
#
#  \a         an ASCII bell character (07)
#  \d         the date in "Weekday Month Date" format (e.g., "Tue May 26")
#  \D{format} the format is passed to strftime(3) and the result
#             is inserted into the prompt string an empty format
#             results in a locale-specific time representation.
#             The braces are required
#  \e         an ASCII escape character (033)
#  \h         the hostname up to the first `.'
#  \H         the hostname
#  \j         the number of jobs currently managed by the shell
#  \l         the basename of the shell's terminal device name
#  \n         newline
#  \r         carriage return
#  \s         the name of the shell, the basename of $0 (the portion following
#             the final slash)
#  \t         the current time in 24-hour HH:MM:SS format
#  \T         the current time in 12-hour HH:MM:SS format
#  \@         the current time in 12-hour am/pm format
#  \A         the current time in 24-hour HH:MM format
#  \u         the username of the current user
#  \v         the version of bash (e.g., 2.00)
#  \V         the release of bash, version + patch level (e.g., 2.00.0)
#  \w         the current working directory, with $HOME abbreviated with a tilde
#  \W         the basename of the current working directory, with $HOME
#             abbreviated with a tilde
#  \!         the history number of this command
#  \#         the command number of this command
#  \$         if the effective UID is 0, a #, otherwise a $
#  \nnn       the character corresponding to the octal number nnn
#  \\         a backslash
#  \[         begin a sequence of non-printing characters, which could be used
#             to embed a terminal control sequence into the prompt
#  \]         end a sequence of non-printing characters
#
#  The command number and the history number are usually different:
#  the history number of a command is its position in the history
#  list, which may include commands restored from the history file
#  (see HISTORY below), while the command number is the position in
#  the sequence of commands executed during the current shell session.
#  After the string is decoded, it is expanded via parameter
#  expansion, command substitution, arithmetic expansion, and quote
#  removal, subject to the value of the promptvars shell option (see
#  the description of the shopt command under SHELL BUILTIN COMMANDS
#  below).

# Build an ansi code sequence string for use in a prompt.
# Expects one or more strings indicating what attributes and colors to use.
# It's up to the caller to make sure the right order and valid keys are used.

#declare -A ansi_code

if ! declare -A ansi_code > /dev/null 2>&1; then

  function __ansi_code() {

    echo do nothing > /dev/null

  }

else

  ansi_code[bold]=$(tput bold)
  ansi_code[dim]=$(tput dim)
  ansi_code[off]=$(tput sgr0)
  ansi_code[underline_on]=$(tput smul)
  ansi_code[underline_off]=$(tput rmul)
  ansi_code[reverse]=$(tput rev)
  ansi_code[stdout_on]=$(tput smso)
  ansi_code[stdout_off]=$(tput rmso)

  # 0 = black
  # 1 = red
  # 2 = green
  # 3 = yellow
  # 4 = blue
  # 5 = purple
  # 6 = cyan
  # 7 = white

  ansi_code[black_fg]=$(tput setaf 0)
  ansi_code[red_fg]=$(tput setaf 1)
  ansi_code[green_fg]=$(tput setaf 2)
  ansi_code[yellow_fg]=$(tput setaf 3)
  ansi_code[blue_fg]=$(tput setaf 4)
  ansi_code[purple_fg]=$(tput setaf 5)
  ansi_code[cyan_fg]=$(tput setaf 6)
  ansi_code[white_fg]=$(tput setaf 7)

  ansi_code[black_bg]=$(tput setab 0)
  ansi_code[red_bg]=$(tput setab 1)
  ansi_code[green_bg]=$(tput setab 2)
  ansi_code[yellow_bg]=$(tput setab 3)
  ansi_code[blue_bg]=$(tput setab 4)
  ansi_code[purple_bg]=$(tput setab 5)
  ansi_code[cyan_bg]=$(tput setab 6)
  ansi_code[white_bg]=$(tput setab 7)

  #ansi_code[blink]=5
  #ansi_code[hide]=8

  function __ansi_code() {

    declare -a codes

    while [ "${1+defined}" ]; do

      if [ -n ${ansi_code[$1]} ]; then

        codes[${#codes[*]}]="${ansi_code[$1]}"

      fi

      shift

    done

    local code

    SAVE_IFS=$IFS
    IFS=''
    code="${codes[*]}"
    IFS=$SAVE_IFS

    printf '\[%s\]' $code

  }

fi

# Create some commonly used codes
text_reset=$(__ansi_code off)

text_blink=$(__ansi_code blink)
text_green=$(__ansi_code green_fg)
text_red=$(__ansi_code red_fg)
text_yellow=$(__ansi_code yellow_fg)
text_cyan=$(__ansi_code cyan_fg)
