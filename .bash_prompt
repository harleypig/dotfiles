#!/bin/bash

debug "${BASH_SOURCE#$HOME/}:$LINENO Entering ..."

# Ideas ripped off and made to fit from:
#   http://wiki.archlinux.org/index.php/Color_Bash_Prompt
#   http://www.termsys.demon.co.uk/vtansi.htm
#   https://gist.github.com/621452
#   https://gist.github.com/623142

declare -a __JOIN
declare -a PROMPT

__buildpath 'PROMPT_FUNCTIONS' "${BASH_SOURCE[0]}" "/.bash_prompt.d"

# shellcheck disable=SC1090
for f in $PROMPT_FUNCTIONS; do source "$f"; done

# Setup ansi codes
text_reset=$(ansi off)
#text_green=$(ansi green_fg)
text_red=$(ansi red_fg)
text_yellow=$(ansi yellow_fg)
text_cyan=$(ansi cyan_fg)

prompt_color=$text_cyan

if [ "$USER" == 'root' ]; then
  # shellcheck disable=SC2154
  user_color=$text_red
else
  user_color=$prompt_color
fi

__update_prompt() {

  local exit_status
  exit_status=$(__exit_status "${PIPESTATUS[@]}")

  local cwd
  cwd=$(__dir_readable)

  # '\D' is a format specifier for bash prompts. See bash manpage, PROMPTING section.
  local datetime="\\D{%a %b %d %Y %T %nDoW: %w DoY: %j Wk: %V Epoch: %s}"

  #local dropbox
  #dropbox=$(__dropbox_status)

  #local fbcmd
  #fbcmd=$(__fbcmd_status)

  local pacman_status
  pacman_status=$(__pacman_status)

  local parent
  parent=$(__parent_process)

  local vcs
  vcs=$(__git_status)

  local versionline
  versionline=$(__versions)

  # Info line

  unset __JOIN
  __JOIN[${#__JOIN[*]}]="Uptime: \$(perl -ne 's/\\s.*\$//;printf\"%.2f\",\$_/(60*60*24)' /proc/uptime) days" # uptime
  __JOIN[${#__JOIN[*]}]="LoadAvg: \$(cat /proc/loadavg | cut -d ' ' -f 1-3)"                                # loadavg
  __JOIN[${#__JOIN[*]}]="\$(df -hP . | grep -v 'Avail' | tr -s ' ' | cut -d ' ' -f 4) available"            # freespace

  separator=' | '
  infoline=$(join_array "$separator" "${__JOIN[@]}")
#  infoline="${infoline//$separator/ $separator }"

  # Build the prompt

  unset PROMPT
  PROMPT[${#PROMPT[*]}]="${parent}${prompt_color}${datetime}"
  PROMPT[${#PROMPT[*]}]="${infoline}"
  PROMPT[${#PROMPT[*]}]="${versionline}"
  PROMPT[${#PROMPT[*]}]="${pacman_status}"

  #[[ -n $dropbox ]] && PROMPT[${#PROMPT[*]}]="${dropbox}"

# Need to handle this better
#  HOSTSPECIFIC="$(__basedir ~/.bash_prompt)/hostspecific/$(hostname)"
#  SOURCE="$(ls ${HOSTSPECIFC}/*prompt* 2> /dev/null)"
#  for s in ${SOURCE}; do source $s; done

  # Append the last command, clear the history cache and reread the history file
  PS1="\$(history -a ; history -c ; history -r)"

  for p in "${PROMPT[@]}"; do PS1="${PS1}\\n ${prompt_color}${p}${text_reset}"; done

  #[[ -n "${fbcmd}" ]] && PS1="${PS1}\n\n${fbcmd}${text_reset}"

  PS1="${PS1}\\n\\n${text_yellow}(tmux|ctl-a) new -s session_name | switch -t session_name | list-sessions${text_reset}"
  PS1="${PS1}\\n\\n ${user_color}\\u@${text_yellow}\\H${prompt_color}: ${cwd}${text_reset}${vcs}"
  PS1="${PS1}\\n ${exit_status} $ "

  #export PS1

}

if [ -n "$PS1" ]; then PROMPT_COMMAND='__update_prompt'; fi
#if [ -n "$PS1" ]; then export PROMPT_COMMAND='__update_prompt'; fi
#export PROMPT_COMMAND=

debug "${BASH_SOURCE#$HOME/}:$LINENO Exiting ..."
