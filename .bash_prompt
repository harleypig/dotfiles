#echo 'Started .bash_prompt ...' >> ~/bash_startup.log

# Ideas ripped off and made to fit from:
#   http://wiki.archlinux.org/index.php/Color_Bash_Prompt
#   http://www.termsys.demon.co.uk/vtansi.htm
#   https://gist.github.com/621452
#   https://gist.github.com/623142

# Peruse /usr/share/doc/xterm/*

# Regular

text_black="\e[0;30m"
text_blue="\e[0;34m"
text_cyan="\e[0;36m"
text_green="\e[0;32m"
text_purple="\e[0;35m"
text_red="\e[0;31m"
text_white="\e[0;37m"
text_yellow="\e[0;33m"

# Background

background_black="\e[40m"
background_blue="\e[44m"
background_cyan="\e[46m"
background_green="\e[42m"
background_purple="\e[45m"
background_red="\e[41m"
background_white="\e[47m"
background_yellow="\e[43m"

# Bold

bold_black="\e[1;30m"
bold_blue="\e[1;34m"
bold_cyan="\e[1;36m"
bold_green="\e[1;32m"
bold_purple="\e[1;35m"
bold_red="\e[1;31m"
bold_white="\e[1;37m"
bold_yellow="\e[1;33m"

# Underline

underline_black="\e[4;30m"
underline_blue="\e[4;34m"
underline_cyan="\e[4;36m"
underline_green="\e[4;32m"
underline_purple="\e[4;35m"
underline_red="\e[4;31m"
underline_white="\e[4;37m"
underline_yellow="\e[4;33m"

# Reset

text_reset="\e[0m"

# Cursor

# Cursor set \[\033[<row>;<column>]f\]
cursor_setbegin="\[\033["
cursor_setend="f\]"

cursor_save="\[\033[s\]"
cursor_restore="\[\033[u\]"

# Erase Text
erase_eol="\[\033[K\]"
erase_sol="\[\033[1K\]"
erase_line="\[\033[2K\]"
erase_down="\[\033[J\]" # Erase from cursor to bottom of screen
erase_up="\[\033[1J\]"  # Erase from cursor to top of screen
erase_screen="\[\033[2J\]"

# Yes, this is needed occasionaly!
blink="\[\033[5m"

# Bash allows these prompt strings to be customized by inserting a
# number of backslash-escaped special characters that are
# decoded as follows:
#
#  \a         an ASCII bell character (07)
#  \d         the date in "Weekday Month Date" format (e.g., "Tue May 26")
#  \D{format} the format is passed to strftime(3) and the result
#             is inserted into the prompt string an empty format
#             results in a locale-specific time representation.
#             The braces are required
#  \e         an ASCII escape character (033)
#  \h         the hostname up to the first `.'
#  \H         the hostname
#  \j         the number of jobs currently managed by the shell
#  \l         the basename of the shell's terminal device name
#  \n         newline
#  \r         carriage return
#  \s         the name of the shell, the basename of $0 (the portion following
#             the final slash)
#  \t         the current time in 24-hour HH:MM:SS format
#  \T         the current time in 12-hour HH:MM:SS format
#  \@         the current time in 12-hour am/pm format
#  \A         the current time in 24-hour HH:MM format
#  \u         the username of the current user
#  \v         the version of bash (e.g., 2.00)
#  \V         the release of bash, version + patch level (e.g., 2.00.0)
#  \w         the current working directory, with $HOME abbreviated with a tilde
#  \W         the basename of the current working directory, with $HOME
#             abbreviated with a tilde
#  \!         the history number of this command
#  \#         the command number of this command
#  \$         if the effective UID is 0, a #, otherwise a $
#  \nnn       the character corresponding to the octal number nnn
#  \\         a backslash
#  \[         begin a sequence of non-printing characters, which could be used
#             to embed a terminal control sequence into the prompt
#  \]         end a sequence of non-printing characters
#
#  The command number and the history number are usually different:
#  the history number of a command is its position in the history
#  list, which may include commands restored from the history file
#  (see HISTORY below), while the command number is the position in
#  the sequence of commands executed during the current shell session.
#  After the string is decoded, it is expanded via parameter
#  expansion, command substitution, arithmetic expansion, and quote
#  removal, subject to the value of the promptvars shell option (see
#  the description of the shopt command under SHELL BUILTIN COMMANDS
#  below).

_update_prompt() {

  local exit="$?"

  case "$exit" in
    "0" ) exitstatus="${text_green}:)${text_reset}" ;;
    *   ) exitstatus="${text_red}:(${text_reset}"   ;;
  esac

  cwd=
  if [ -w "${PWD}" ]; then cwd="${text_green}"; else cwd="${text_red}"; fi
  cwd="${cwd}${PWD}${text_reset}"

  DROPBOX=$(which dropbox 2> /dev/null)
  dropbox=
  [[ -x ${DROPBOX} ]] && dropbox="Dropbox: $($DROPBOX status | perl -07 -pe 's/\n+$//;s/\n+/ : /g')"

  vim=
  [[ -n ${MYVIMRC} ]] && vim="${text_red}${blink}(VIm)${text_reset} "

  datetime="\D{%a %b %d %Y %T %n DoW: %w DoY: %j Wk: %V Epoch: %s}"

  vcs=

  # Most of this git functionality came from
  # https://gist.github.com/623142

  GIT=$(which git 2> /dev/null)

  if [ -x ${GIT} ]; then

    GITDIR=$(__gitdir)

    if [ -n "${GITDIR}" ]; then

      branch=$(__git_ps1 " (%s)")

      if [ -n ${branch} ]; then

        git status --porcelain | perl -ne 'exit 1 if /^ /; exit 2 if /^?/'

        case "$?" in
          "0" ) vcs="${text_green}"  ;;
          "1" ) vcs="${text_yellow}" ;;
          "2" ) vcs="${text_red}"    ;;
        esac

        vcs="${vcs}${branch}${text_reset}"

      fi
    fi
  fi

  current_song=

  if [[ -f ~/Documents/Grooveshark/currentSong.txt ]]; then

    SONG=$(grep playing ~/Documents/Grooveshark/currentSong.txt | cut -d '	' -f 1,2,3 | tr '\t' ':')
    SONG="${SONG//:/ : }"

    if [[ -n ${SONG} ]]; then current_song="${SONG}"; fi

  fi

  # Info line
  declare -a INFO

  INFO[${#INFO[*]}]="Uptime: \$(perl -ne 's/\s.*\$//;printf\"%.2f\",\$_/(60*60*24)' /proc/uptime) days" # uptime
  INFO[${#INFO[*]}]="LoadAvg: \$(cat /proc/loadavg | cut -d ' ' -f 1-3)"                                # loadavg
  INFO[${#INFO[*]}]="\$(df -hP . | grep -v 'Avail' | tr -s ' ' | cut -d ' ' -f 4) available"            # freespace

  [[ -n ${dropbox} ]] && INFO[${#INFO[*]}]=${dropbox}

  SAVE_IFS="$IFS"
  IFS="|"
  infoline="${INFO[*]}"
  IFS="$SAVE_IFS"
  infoline="${infoline//|/ | }"

  # Build the prompt
  declare -a PROMPT

  PROMPT[${#PROMPT[*]}]="${vim}${text_cyan}${datetime}"
  PROMPT[${#PROMPT[*]}]="${infoline}"
  [[ -n "${current_song}" ]] && PROMPT[${#PROMPT[*]}]="${current_song}"

  HOSTSPECIFIC="$(__basedir ~/.bash_prompt))/hostspecific/$(hostname)"
  SOURCE="$(ls ${HOSTSPECIFC}/*prompt* 2> /dev/null)"
  for s in ${SOURCE}; do source $s; done

  PS1="${erase_line}\$(history -a)"

  for p in "${PROMPT[@]}"; do PS1="${PS1}\n${erase_line} ${text_cyan}${p}${text_reset}"; done

  PS1="${PS1}\n${erase_line}\n${erase_line} ${text_cyan}\u@${text_yellow}\H${text_cyan}: ${cwd}${text_reset}${vcs}"
  PS1="${PS1}\n${erase_line} ${exitstatus} $ "

  export PS1

}

if [ -n "$PS1" ]; then export PROMPT_COMMAND='_update_prompt'; fi

#echo '  ... ended .bash_prompt.' >> ~/bash_startup.log
