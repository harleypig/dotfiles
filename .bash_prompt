#echo 'Started .bash_prompt ...' >> ~/bash_startup.log

# Ideas ripped off and made to fit from:
#   http://wiki.archlinux.org/index.php/Color_Bash_Prompt
#   http://www.termsys.demon.co.uk/vtansi.htm
#   https://gist.github.com/621452
#   https://gist.github.com/623142

# TODO:

#   Allow for arbitrary scripts to be run under certain conditions.  E.g.,
#   directory change for location specific aliases.

PROMPT_FUNCTIONS="$(__basedir ~/.bash_prompt)/.bash_prompt.d"
FUNCS=$(ls ${PROMPT_FUNCTIONS}/* 2> /dev/null)
for f in ${FUNCS}; do source $f; done

prompt_color=$(__ansi_code cyan_fg)

__update_prompt() {

  local exit="$?"

  # used to join bits of data in one line
  declare -a __JOIN

#  exec_time="($(perl -MTime::HiRes=time -e 'printf "%.6f", Time::HiRes::time() - $ENV{start_time}')) "

  current_song=$(__grooveshark_status)
  cwd=$(__dir_readable)
  datetime="\D{%a %b %d %Y %T %nDoW: %w DoY: %j Wk: %V Epoch: %s}"
  dropbox=$(__dropbox_status)
  exit_status=$(__exit_status $exit)
  parent=$(__parent_process)
  vcs=$(__git_status)

  perlv='not installed'
  if command -v perl > /dev/null; then

    perlv=$(perl -e 'print $]')

  fi

  pythonv='not installed'
  if command -v python > /dev/null; then

    pythonv=$(python -V 2>&1 | cut -d ' ' -f 2)

  fi

  rubyv='not installed'
  if command -v ruby > /dev/null; then

    rubyv=$(ruby -v)

  fi

  # Info line

  unset __JOIN
  __JOIN[${#__JOIN[*]}]="Uptime: \$(perl -ne 's/\s.*\$//;printf\"%.2f\",\$_/(60*60*24)' /proc/uptime) days" # uptime
  __JOIN[${#__JOIN[*]}]="LoadAvg: \$(cat /proc/loadavg | cut -d ' ' -f 1-3)"                                # loadavg
  __JOIN[${#__JOIN[*]}]="\$(df -hP . | grep -v 'Avail' | tr -s ' ' | cut -d ' ' -f 4) available"            # freespace

  [[ -n ${dropbox} ]] && __JOIN[${#__JOIN[*]}]=${dropbox}

  separator='|'
  infoline=$(__join $separator)
  infoline="${infoline//$separator/ $separator }"

  # Version line

  unset __JOIN
  __JOIN[${#__JOIN[*]}]="Perl ${perlv}"
  __JOIN[${#__JOIN[*]}]="Python ${pythonv}"
  __JOIN[${#__JOIN[*]}]="Ruby ${rubyv}"

  separator='|'
  versionline=$(__join $separator)
  versionline="${versionline//$separator/ $separator }"

  # Build the prompt
  declare -a PROMPT

  PROMPT[${#PROMPT[*]}]="${parent}${prompt_color}${datetime}"
  PROMPT[${#PROMPT[*]}]="${infoline}"
  PROMPT[${#PROMPT[*]}]="${versionline}"
  [[ -n "${current_song}" ]] && PROMPT[${#PROMPT[*]}]="${current_song}"

  HOSTSPECIFIC="$(__basedir ~/.bash_prompt)/hostspecific/$(hostname)"
  SOURCE="$(ls ${HOSTSPECIFC}/*prompt* 2> /dev/null)"
  for s in ${SOURCE}; do source $s; done

  PS1="\$(history -a)"

  for p in "${PROMPT[@]}"; do PS1="${PS1}\n ${prompt_color}${p}${text_reset}"; done

  PS1="${PS1}\n\n ${prompt_color}\u@${text_yellow}\H${prompt_color}: ${cwd}${text_reset}${vcs}"

  text_red=$(__ansi_code red_fg)
  PS1="${PS1}\n\n  ${text_red}CHECK OUT http://smartcd.org${prompt_color}\n"

  PS1="${PS1}\n ${exit_status} $ "

  export PS1

}

if [ -n "$PS1" ]; then export PROMPT_COMMAND='__update_prompt'; fi
#export PROMPT_COMMAND=

#echo '  ... ended .bash_prompt.' >> ~/bash_startup.log
