git_normal_color=$(__ansi_code green_fg)
git_unstaged_color=$(__ansi_code yellow_fg)
git_staged_color=$(__ansi_code red_fg)
git_push_color=$(__ansi_code red_bg yellow_fg)
git_pull_color=$(__ansi_code red_bg yellow_fg)
git_pull_text='PULL'
git_push_text='PUSH'

function __git_status() {

  # Most of this git functionality came from
  # https://gist.github.com/623142

  # If you want/need multiple repository checking,
  # have a look at http://glandium.org/blog/?p=170

  GIT=$(command -v git)

  if [ -x ${GIT} ]; then

    GITDIR=$(__gitdir)

    if [ -n "${GITDIR}" ]; then

# from /etc/bash_completion.d/git
#
#    3) Consider changing your PS1 to also show the current branch:
#        PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
#
#       The argument to __git_ps1 will be displayed only if you
#       are currently in a git repository.  The %s token will be
#       the name of the current branch.
#
#       In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty
#       value, unstaged (*) and staged (+) changes will be shown next
#       to the branch name.  You can configure this per-repository
#       with the bash.showDirtyState variable, which defaults to true
#       once GIT_PS1_SHOWDIRTYSTATE is enabled.
#
#       You can also see if currently something is stashed, by setting
#       GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
#       then a '$' will be shown next to the branch name.
#
#       If you would like to see if there're untracked files, then you can
#       set GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're
#       untracked files, then a '%' will be shown next to the branch name.
#
#       If you would like to see the difference between HEAD and its
#       upstream, set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates
#       you are behind, ">" indicates you are ahead, and "<>"
#       indicates you have diverged.  You can further control
#       behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated
#       list of values:
#           verbose       show number of commits ahead/behind (+/-) upstream
#           legacy        don't use the '--count' option available in recent
#                         versions of git-rev-list
#           git           always compare HEAD to @{upstream}
#           svn           always compare HEAD to your SVN upstream
#       By default, __git_ps1 will compare HEAD to your SVN upstream
#       if it can find one, or @{upstream} otherwise.  Once you have
#       set GIT_PS1_SHOWUPSTREAM, you can override it on a
#       per-repository basis by setting the bash.showUpstream config
#       variable.

      GIT_PS1_SHOWDIRTYSTATE=1
      GIT_PS1_SHOWSTASHSTATE=1
      GIT_PS1_SHOWUNTRACKEDFILES=1
      GIT_PS1_SHOWUPSTREAM="auto"

      info=$(__git_ps1 '%s')

      if [ -n "${info}" ]; then

        branch=$(echo    "$info" | perl -ane '$F[0]=~s/[<>=]$//;print $F[0]')
        unstaged=$(echo  "$info" | perl -ane 'print $F[1]=~/\*/')
        staged=$(echo    "$info" | perl -ane 'print $F[1]=~/\+/')
        stashed=$(echo   "$info" | perl -ane 'print $F[1]=~/\$/')
        untracked=$(echo "$info" | perl -ane 'print $F[1]=~/\%/')
        behind=$(echo    "$info" | perl -ane 'print $F[1]=~/\</ || $F[0]=~/\<$/')
        ahead=$(echo     "$info" | perl -ane 'print $F[1]=~/\>/ || $F[0]=~/\>$/')

        status_color="$git_normal_color"
        if [ -n "$unstaged" ]; then status_color="$git_unstaged_color"; fi
        if [ -n "$staged" ];   then status_color="$git_staged_color"; fi

        upstream=
        if [ -n "$behind" ]; then upstream=" $git_pull_color$git_pull_text$text_reset"; fi
        if [ -n "$ahead" ];  then upstream=" $git_push_color$git_push_text$text_reset"; fi

        repo=$(basename $(git rev-parse --show-toplevel))

        printf ' %s(%s: %s%s)%s' $status_color $repo $branch $upstream $text_reset

      fi
    fi
  fi

}
