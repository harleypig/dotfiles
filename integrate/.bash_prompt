#!/bin/bash

# Ideas ripped off and made to fit from:
#   http://wiki.archlinux.org/index.php/Color_Bash_Prompt
#   http://www.termsys.demon.co.uk/vtansi.htm
#   https://gist.github.com/621452
#   https://gist.github.com/623142

#----------------------------------------------------------------------------

source utility

sourced || die ".bash_prompt must only be sourced"

#----------------------------------------------------------------------------
# Only setup the prompt if we are in an interactive session

[[ $- == *i* ]] || {
  debug "Not in interactive mode."
  return 0
}

#----------------------------------------------------------------------------
prompt_color="$(ansi -n fg cyan)"
color_off="$(ansi -n off)"

#----------------------------------------------------------------------------
function _parent() {

  command -v pstree &> /dev/null || return 0

  local parents

  parents=$(pstree -A $PPID 2> /dev/null) || { return 1; }

  parents=${parents/%-+*/}
  parents=${parents//tmux/}
  parents=${parents//sshd/}
  parents=${parents//---bash/}
  parents=${parents//---pstree/}
  parents=${parents//gnome-terminal-/}
  parents=${parents//: server/}
  parents=${parents//su/}

  [[ -n $parents ]] \
    && printf '\[%s\](%s)\[%s\] ' "$(ansi -n fg bright_yellow bg red)" "$parents" "$(ansi -n off)"
}

#----------------------------------------------------------------------------
function _exit_status() {
  local -a status

  local color_bad color_good

  color_bad="$(ansi -n bg red fg white)"
  color_good="$(ansi -n bg blue fg yellow)"

  for s in "$@"; do

    # Wrap the exit symbols in appropriate ansi codes.

    # If a command is still writing to the pipe and a later command exits, the
    # first command will exit with a status of 141.  This causes confusion
    # with commands like echo or head.

    # Doing this *will* cause confusion if something does exit abnormally but
    # doesn't throw an appropriate exit status.

    case "$s" in
      0 | 141) status+="$color_good $s $color_off" ;;
      *) status+="$color_bad $s $color_off" ;;
    esac

    #status+=("$status_color $s $color_off")
  done

  statuscodes=$(join_array ' | ' 'status')

  printf '%s' "$statuscodes"
}

#----------------------------------------------------------------------------
# XXX: Move out of this file. Maybe look for .bash_prompt.d?
# XXX: Maybe move all of these functions out and look for .d directories in
#      multiple places?

_prjenv() {
  local -u environment="${PRJ_ENVIRONMENT:-$USER}"

  case $environment in
    DEV) color_env="$(ansi -n fg bright_green)" ;;
    TEST) color_env="$(ansi -n fg green)" ;;
    STG) color_env="$(ansi -n fg red)" ;;
    PROD) color_env="$(ansi -n fg bright_yellow bg red)" ;;
    *) color_env="$(ansi -n fg bright_yellow bg red)" ;;
  esac

  printf '%s' "$color_env$environment$(ansi -n off)"
}

#----------------------------------------------------------------------------
_mail() {
  mail -e &> /dev/null || return 0
  printf '%sMAIL%s ' "$(ansi -n fg bright_purple)" "$(ansi -n off)"
}

#----------------------------------------------------------------------------
# Are we in a repo? If so, what branch are we on?

_gitbranch() {
  in_repo=$(git rev-parse --is-inside-work-tree 2> /dev/null) || return 0
  [[ $in_repo == 'false' ]] && return 0
  printf ' %s(%s)' "$(ansi -n fg blue)" "$(git rev-parse --abbrev-ref HEAD)"
}

#----------------------------------------------------------------------------
_update_prompt() {

  # don't use 'local exit_status' here because it wipes out PIPESTATUS.
  exit_status=$(_exit_status "${PIPESTATUS[@]}")

  local msgfile="$HOME/.prompt_msg"

  PS1="$prompt_color"

  # XXX: Move this out to a function
  [[ -f $msgfile ]] && PS1+="$(cat "$msgfile")\n"

  # XXX: Create a default, but look for a definition string in .d?

  PS1+="$(_parent)$(_mail)"
  PS1+="$prompt_color${PRJ_NAME^^} $(_prjenv) "
  PS1+="$prompt_color\h "
  PS1+="$(dir_readable)$(_gitbranch)\n"
  #PS1+="$(dir_readable)$(git-status)\n"
  #PS1+="$(dir_readable)\n"
  PS1+="${exit_status} "
  PS1+="$(ansi -n off)$ "
}

[[ -n $PS1 ]] && PROMPT_COMMAND='_update_prompt'
