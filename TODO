XXX: Convert as many functions to scripts as possible so they aren't taking up memory.

Possibly convert things setup and run from .bashrc into a separate file for each application or function it's used for.

Something like

.bashrc.d
  git - contains functions and aliases and such used for git
  prompt - contains functions and aliases and such used for the prompt
  etc...

See https://github.com/jcayzac/dotfiles

Modify symlink.sh to accept parameter which reads a file containing a list of symlinks to create:

symlink.sh harleypig.com
symlink.sh work.desk

instead of copying all dotfiles blindly.

try using rsync instead:
  https://github.com/mathiasbynens/dotfiles/blob/master/bootstrap.sh

#!/bin/bash

#-----------------------------------------------------------------------------
# PREAMBLE FOR EVERY SCRIPT
# Can these be incorporated in a utility script?

# https://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/
unset CDPATH

#-----------------------------------------------------------------------------
# XXX: How does this compare with what I've already done?

# https://stackoverflow.com/a/246128/491894

SOURCE="${BASH_SOURCE[0]}"

# resolve $SOURCE until the file is no longer a symlink
while [ -h "$SOURCE" ]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "$SOURCE")"

  # if $SOURCE was a relative symlink, we need to resolve it relative to the
  # path where the symlink file was located
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done

DIR="$(cd -P "$(dirname "$SOURCE")" > /dev/null 2>&1 && pwd)"

#-----------------------------------------------------------------------------
# Does command exist and is it executable?

# https://stackoverflow.com/a/26759734/491894
[[ -x "$(command -v app)" ]] || die 'app required'

#-----------------------------------------------------------------------------
# XXX: Can I use any of this in ParseParams?

# https://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash

#-----------------------------------------------------------------------------
# Mine and compare originals/*.msys2 and see what I can incorporate

# These?
# https://github.com/bashup/realpaths
# https://github.com/bashup/mdsh

#-----------------------------------------------------------------------------
ChatGPT Notes

Organize the repository structure:

Create the following directories within your 'dotfiles' repository:

Move and reorganize existing files:

Move the 'shell_startup' file to the 'rcs' directory and link it to .bashrc, .bash_profile, and .profile.
Move all aliases and bash completions to the 'rcs' directory.
Identify and move most functions to the 'bin' directory as executables, keeping only a few exceptions in the 'rcs' directory.
Optimize memory usage and startup time:

Evaluate your current setup and identify areas where startup time and memory usage can be improved.
Use lazy loading for seldom-used functions.
Avoid unnecessary commands and external dependencies.
Create documentation:

Generate a Vimwiki in the 'docs' directory using markdown format.
For each file in the 'rcs' and 'bin' directories, create appropriate file documentation within the 'docs' directory.
Ensure that the documentation is up-to-date and provides a clear explanation of each component.
Set up tests:

Install the BATS testing framework in your 'dotfiles' repository.
Create test files in the 'tests' directory for each component, following the BATS syntax.
Write tests to ensure correct functionality for each component.
Set up continuous integration:

Create a GitHub repository for your 'dotfiles' and push your local changes.
Set up GitHub Actions for automated testing and linting across different versions of bash and Linux distributions.
Create a .github/workflows/main.yml file to define your CI pipeline, including running BATS tests and shellcheck linting.
Iterate and improve:

Continuously review and update your 'dotfiles' setup, making improvements to performance and organization as needed.
Regularly update your documentation and tests to ensure they remain accurate and up-to-date.
Example data:
Note that the following directory structure, file names, and contents are examples to provide guidance and can be adapted as needed.

css
Copy code
dotfiles/
├── rcs/
│   ├── shell_startup
│   ├── aliases
│   └── completions
├── bin/
│   ├── custom_command_1
│   └── custom_command_2
├── tests/
│   ├── test_aliases.bats
│   ├── test_completions.bats
│   └── test_custom_commands.bats
├── docs/
│   ├── index.md
│   ├── shell_startup.md
│   ├── aliases.md
│   ├── completions.md
│   ├── custom_command_1.md
│   └── custom_command_2.md
└── .github/
    └── workflows/
        └── main.yml
Add tests for the add_repo role:
1. Variable Definition Test: Verify that all required variables are defined for each repository.
2. Repository Key Installation Test: Check if the repository public key is correctly installed on the system.
3. Repository Addition Test: Ensure that the repository is correctly added to the system's package manager.
4. Idempotence Test: Confirm that running the role/task again does not make any changes if the repository is already added.
5. Error Handling Test: Test the role's ability to handle errors, such as attempting to add an undefined repository.
6. Validation Test: Verify that the validation step correctly identifies undefined repositories and provides a meaningful error message.
7. Platform Compatibility Test: Ensure that the role works across different distributions or versions if applicable.
8. Security Test: Check that the key installation process is secure and that keys are obtained from a trusted source.
9. Cleanup Test: If the role includes the ability to remove repositories, test that the removal process works correctly and cleans up any associated files.
